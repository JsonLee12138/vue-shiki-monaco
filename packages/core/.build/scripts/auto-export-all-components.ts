/* eslint-disable regexp/optimal-quantifier-concatenation */
/* eslint-disable regexp/no-super-linear-backtracking */
// oxlint-disable no-console
// build/scripts/auto-export-all-components.ts
import childProcess from 'node:child_process';
import path from 'node:path';
import { cwd, exit } from 'node:process';
import { promisify } from 'node:util';
import fs from 'fs-extra';

interface ComponentInfo {
  name: string;
  path: string;
  dirName: string; // 添加目录名
  hasInstall?: boolean;
}

interface HookInfo {
  name: string;
  path: string;
  types: string[];
}

async function scanComponents(): Promise<ComponentInfo[]> {
  const componentsDir = path.resolve(cwd(), 'src/components');
  const components: ComponentInfo[] = [];

  if (await fs.exists(componentsDir)) {
    const dirs = await fs.readdir(componentsDir);

    for (const dir of dirs) {
      if (dir === 'index.ts')
        continue;

      const compPath = path.join(componentsDir, dir, 'index.vue');
      const installPath = path.join(componentsDir, dir, 'install.ts');

      if (await fs.exists(compPath)) {
        const compName = dir.replace(/(^\w|-\w)/g, (m: string) =>
          m.replace('-', '').toUpperCase());

        components.push({
          name: compName,
          dirName: dir, // 存储原始目录名
          path: `./components/${dir}/index.vue`,
          hasInstall: await fs.exists(installPath),
        });
      }
    }
  }

  return components;
}

async function scanHooks(): Promise<HookInfo[]> {
  const hooksDir = path.resolve(cwd(), 'src/hooks');
  const hooks: HookInfo[] = [];

  if (await fs.exists(hooksDir)) {
    const dirs = await fs.readdir(hooksDir);

    for (const dir of dirs) {
      if (dir === 'index.ts')
        continue;

      const hookPath = path.join(hooksDir, dir, 'index.ts');

      if (await fs.exists(hookPath)) {
        // 读取hook文件内容来提取导出的类型
        const content = await fs.readFile(hookPath, 'utf-8');
        const types = extractExportedTypes(content as any);

        const hookName = dir.replace(/(^\w|-\w)/g, (m: string) =>
          m.replace('-', '').toLowerCase());

        hooks.push({
          name: hookName,
          path: `./hooks/${dir}`,
          types,
        });
      }
    }
  }

  return hooks;
}

function extractExportedTypes(content: string): string[] {
  const typeExports = content.match(/export\s+(?:type\s+)?\{\s*([^}]+)\s*\}/g) || [];
  const types: string[] = [];

  typeExports.forEach((exp) => {
    const match = exp.match(/\{\s*([^}]+)\s*\}/);
    if (match) {
      const exports = match[1].split(',').map(e => e.trim().replace(/^type\s+/, ''));
      types.push(...exports);
    }
  });

  return types;
}

async function generateAutoEntry() {
  const components = await scanComponents();
  const hooks = await scanHooks();

  // 生成components.ts - 组件专用导出文件
  const componentsContent = [
    '// Auto-generated by auto-export-all-components script',
    '// 组件导出（支持按需导入和树摇）',
    '',
    ...components.map(c => `export { default as ${c.name} } from '${c.path}'`),
    ...components.filter(c => c.hasInstall).map(c =>
      `export { default as ${c.name}WithInstall } from './components/${c.dirName}/install'`,
    ),
    '',
  ].join('\n');

  // 生成hooks.ts - hooks专用导出文件
  const hooksContent = [
    '// Auto-generated by auto-export-all-components script',
    '// Hooks导出（支持按需导入和树摇）',
    '',
    ...hooks.map(h => `export * from '${h.path}'`),
    '',
  ].join('\n');

  // 生成完整的index.ts - 全量导出 + 插件
  const indexContent = [
    '// Auto-generated by auto-export-all-components script',
    'import type { App, Plugin } from \'vue\'',
    '',
    '// 组件导入',
    ...components.map(c => `import ${c.name} from '${c.path}'`),
    '',
    '// 全量导出（保持向后兼容）',
    'export * from \'./components\'',
    'export * from \'./hooks\'',
    '',
    '// 全局插件',
    'const VueElementPlusXShikiMonaco: Plugin = {',
    '  install(app: App) {',
    ...components.map(c => `    app.component('${c.name}', ${c.name})`),
    '  },',
    '}',
    '',
    'export { VueElementPlusXShikiMonaco }',
    'export default VueElementPlusXShikiMonaco',
    '',
  ].join('\n');

  // 写入文件
  const outputDir = path.resolve(cwd(), 'src');

  try {
    await fs.ensureDir(outputDir);

    const files = [
      { name: 'components.ts', content: componentsContent },
      { name: 'hooks.ts', content: hooksContent },
      { name: 'index.ts', content: indexContent },
    ];

    for (const file of files) {
      const filePath = path.join(outputDir, file.name);
      await fs.writeFile(filePath, file.content);
      console.log(`✅ Generated: ${file.name}`);
    }

    const execAsync = promisify(childProcess.exec);

    try {
      const fileList = files.map(f => `"${path.join(outputDir, f.name)}"`).join(' ');
      await execAsync(`npx eslint --fix ${fileList}`);
      console.log('✅ ESLint formatting completed');
    }
    catch (error) {
      console.warn('⚠️ Eslint formatting failed:', error);
    }
  }
  catch (error) {
    console.error('❌ Error generating auto-entry files:', error);
    exit(1);
  }
}

// 执行生成
void generateAutoEntry();
